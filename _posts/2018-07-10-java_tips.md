---
layout: post
title: "정리되지 않은 자바 tip"
---

######가독성을 높이기 위해 클래스, 함수, 변수 선언 시 줄바꿈을 해줄 것.
---

##메모리를 사용하는 규칙
---
먼저 어떤 성질(정수, 실수, 문자, 논리값)의 값을 기억시킬지 지정   

여러 개의 메모리들을 구분시키기 위한 구분자 - 이름


##data type identifier
---
boolean(true, false) - 논리값(참, 거짓)
byte, char(문자), short, int, long - 정수
float, double - 실수

byte(1) - char(2) - short(2) - int(4) - long(8) - float(4) - double(8)   
※ char형은 자바에서는 유니코드(2 byte 문자체계)를 사용하므로 2byte이고, C언어에서는 ASCII코드를 사용하여 1byte이다.

long보다 float가 숫자를 더 많이 표현할 수 있음   


##변수 명명 규칙
---
1) 첫 글자는 문자이거나 ' $ ', ' _ '여야 하고, 숫자는 불가능

2) 소문자 대문자가 구별된다

3) 첫문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫자를 대문자로 한다(관례)
ex) maxSpeed, firstName, carBodyColor

4) 문자 수의 제한은 없음

5) 자바 예약어는 사용할 수 없음.

##타입 변환
---
1) 자동 타입 변환(promotion)   
ex)
	byte b1 = 3;
	int b = 4;
	b = b1 + 1;

==> b = b1 + 1;에서 1은 기본적으로 int형이다(1.0은 기본적으로 double형을 가짐)
    b는 int형이고 b1은 byte형인데 int형이 더 큰 타입이므로 int형으로 자동적으로 타입이 변환됨

2) 강제 타입 변환(casting)
ex)
	int a = 3;
	double b = 2.5;
	a = (int)b + 1;   


##데이터 타입에 표현 가능한 범위를 초과하여 쓰고싶은 경우 뒤에 'L'을 써준다
---
ex) long var3 = 10000000000000L;    


##연산자 비교
---
1) ++ -- + - ~ !

2) / * %

3) + -

4) << >> >>>

5) < <= > >= == !=

6) & ^ |

7) && ||

8) ?:

9) = += -= /= %= <<= >>= >>>= &= ^= |=


##assignment(할당, 대입)
---
variable = variable
	   literal
	   expression
	   operator

##이중 for문에서 벗어나는 법
---
라벨을 사용   
ex)
Outter: for(~~~){
		for(~~~){
		if(~~~) break Outter;
		}
	}


#### continue: 아래 조건문을 무시하고 for문 최상단으로 올라가 다음 반복문을 진행



#### 같은 이름의 메소드에서 받는 인자를 다르게 하면 메소드 호출 시 받는 인자에 맞는 메소드를 호출한다.



####메소드명에 'has'가 포함되어있으면 대부분 리턴값을 bool로 한다.


## While문과 do-While문의 차이점
---
while문은 조건문이 앞에 있어서 조건을 만족하지 않으면 실행하지 않지만, do-while문은 조건문이 맨 끝에 있기 때문에 한번 실행한 후 조건을 검사하는 차이가 있다.



## 문자열 변환
---
+Integer.parseInt(string변수) : 문자열을 int형으로 변환시켜줌   
+Double.parseDouble(string변수) : 문자을열 double형으로 변환시켜줌   
+Integer.toString(숫자 변수) : 숫자로 된 변수를 문자열로 바꿔줌   


## JVM이 사용하는 메모리 영역
- 메소드 영역
	- JVM 시작할 때 생성
	- 로딩된 클래스 바이트 코드 내용을 분석 후 저장
	- 모든 스레드가 공유

- 힙 영역
	- JVM 시작할 때 생성
	- 객체/배열 저장
	- 사용되지 않는 객체는 Garbage Collector가 자동 제거

* JVM 스택
	* 스레드 별 생성
	* 메소드 호출할 때 마다 Frame을 생성한 후 스택에 추가


## NULL(널)
---
* 변수가 참조하는 객체가 없을 경우 초기값으로 사용가능
* 참조 타입의 변수에만 저장가능
* null로 초기화된 참조 변수는 스택영역에 생성


## String 타입
---
* 문자열 리터럴이 동일하다면 String 객체 공유
 ==> 같은 주소를 가리킨다.


* new연산자를 이용하여 String 객체 생성
==> 힙 영역에 새로운 String 객체 생성


* String객체를 생성한 후 번지 리턴
ex) String name1 = new String("신용권");
    String name2 = new String("신용권");
==> 같은 값이지만 객체를 새로 생성했기 때문에 다른 주소를 가지고 있다.

## 배열 선언
* 타입[] 변수;   
ex) int[] intArray;
    double[] doubleArray;


* 타입 변수[];   
ex) int intArray[];
    double doubleArray[];

==>배열 변수는 참조 변수 -> 배열 생되기 전 null로 초기화 가능. 배열 변수가 null을 가진 상태에서는 사용 불가


## 열거

* 한정된 값인 열거 상수 정의
	* 열거 상수 이름은 관례적으로 모두 대문자로 작성
	* 다른 단어가 결합된 이름일 경우 관례적으로 밑줄( _ )로 연결


## 객체지향 프로그래밍(OOP)
---
**Object Oriented Programming**

**객체(Object)**
	* 무리적으로 존재하는 것(EX. 자동차, 책, 사람)
 	* 추상적인 것(회사, 날짜)중에서 자신의 속성과 동작을 가지는 모든 것
	* 객체는 필드(속성)과 메소드(동작)로 구성된 자바 객체로 모델링 가능
	* 객체간의 관계 : 객체 지향 프로그램에서는 객체는 다른 객체와 관계를 맺음

A. 캡슐화
 	* 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것
	* 자바 언어는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지 결정하기 위한 접근 제한자를 사용

B. 상속
	* 상위(부모) 객체의 필드와 메소드를 하위(자식) 객체에게 물려주는 행위
 	* 하위 객체는 상위 객체를 확장해서 추가적인 필드와 메소드를 가질 수 잇음
 	* 상속 대상 : 필드와 메소드
 	* 효과
   	* 상위 객체를 재사용해서 하위 객체를 빨리 개발 가능
  	* 반복된 코드의 중복을 줄임

C. 다형성
	* 같은 타입이지만 실행 결과가 다양한 객체를 대입할 수 있는 성질

## 클래스
* 첫글자는 대문자로
* 소스 파일당 하나의 클래스를 선언하는 것이 관례
	* 두 개 이상의 클래스도 선언 가능
* new 연산자: 객체 생성 역할
	* ex) new 클래스();
  * 클래스()는 생성자를 호출하는 코드
  * 생성된 객체는 힙 메모리 영역에 생성
* 구성멤버   
A. **필드(Field)** : 객체의 데이터가 저장되는 곳
ex) int fieldName;


B. **생성자(Constructor)** : 객체 생성시 초기화 역할 담당
ex) ClassName() { }

   
C. **메소드(method)** : 객체의 동작을 구현
ex) public void method() { }
